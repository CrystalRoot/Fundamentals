/*Expansive comments are for my own educational purposes and not due to a misunderstanding of standards. */

/* */

/*Initialize global constant using upper snake case naming convention; constant contains an array of 10 different HTML-valid color names. */
const COLORS_ARRAY = ["green", "lime", "forest green", "moss green", "medium sea green", "sea green", "olive", "yellow green", "spring green", "pale green", "dark green"]

function runGame() {
    /*Declare variable initialized to an empty string. This will hold the color that the player guesses in each iteration of the loop. */
    let guess = "";
    /*Declare variable initialized to Boolean false. For the game to exit the loop, this condition must change to "true". */
    let correct = false;
    /*Declare variable initialized to 0. This will hold the number of tries it takes to guess the color, and will increase by 1 with each iteration. */
    let numTries = 0;
    /*Declare variable to hold the contents of the colors array first sorted into alphabetical order and then converted to a string, each item joined by a comma and a whitespace character. This will make it look better when it appears in the browser alert.*/
    let sortedColors = COLORS_ARRAY.sort().join(", ")
    /*Declare variable and assign to it one random index number from the colors array. This is found by calling Math.random on the length property of the colors array, giving us a random decimal number between 0 and the length of the array. Then we subtract 1 from this number, as arrays are 0-indexed, meaning the length will always be one more than the highest index. Then we call Math.floor on the result, rounding targetIndex down to the nearest whole number. This variable now holds a random index number from the array. */
    const targetIndex = Math.floor(Math.random() * COLORS_ARRAY.length - 1);
    /*Declare a variable and assign to it the value returned from using bracket notation to return the value associated with the index number generated in the step above. */
    const target = COLORS_ARRAY[targetIndex];
    /*Begin do-while loop. This specifies a set of operations to perform WHILE the while condition is met. When the while condition is not met, the loop exits. */
    do {
        /*Use the variable "guess" initialized above to hold the input generated by a player. */
        guess = prompt("I am thinking of one of these colors:\n\n" + sortedColors + "\n\nWhat color am I thinking of?")
        // casedGuess = guess.toLowerCase();
        /*Corrects error where clicking the cancel button is interpreted as entering 0. Clicking 'cancel' causes the return value of the prompt function to be null, which Javascript then automatically uses type coercion to convert to 0, which is outside the range set for the game. Checking for this and simply returning breaks out of the loop and ends the game. */
        if (guess === null) {
            return;
        }
        /*Increments numTries variable by 1 with each iteration. I had had this line positioned AFTER the next line, as that was how the instructions said to do it, but it was not incrementing correctly. */
        numTries += 1;
        /*Takes the return value of the checkGuess function below (either true or false), passing in params guess, target, and numTries, and returns a Boolean value of true/false depending on whether guess and target match. */
        correct = checkGuess(guess.toLowerCase(), target.toLowerCase(), numTries);
        /*While condition. While the Boolean value held in "correct" is not true, this loop will continue to iterate. Once it evaluates to true, the loop will exit and the lines of code below it will then run. */
    } while (!correct);
    /*This alert will only be triggered when the do-while loop exits. */
    alert("You are correct! My color was " + target + "!\nCongratulations! It took you " + numTries + " tries to guess.\nClick OK to see the color on your screen.");
    console.log("Target color: ", target);
    /*The project instructions provided most of this line of code to change the color of the HTML body element to whichever color is held in the "guess" value. I found this was only working with single-word color names. Began troubleshooting by changing to the "target" value instead. Used console.log to make sure values were being passed correctly. Troubleshooting suggestions included complicated things like declaring an object with key-value pairs to map the proper hex codes for the multi-word entries. Had to be a simpler solution. On a whim tried seeing if removing the whitespace using regex would make it work, and it did. This calls "replace" on the string value held in "target". /s matches any whitespace character, and g insures it replaces all occurences, not just the first. This is replaced with whatever is inside the "" which in this case is nothing. */
    document.body.style.background = target.replace(/\s/g, "");
}

function checkGuess(guess, target, numTries) {
    /*Initialize variable to Boolean value of false. */
    let result = false;
    /*Series of if/else if/else statements. If the colors array does not include the player's guess, this alert will be triggered. */
    if (!COLORS_ARRAY.includes(guess)) {
        alert("You have not entered a valid color in the list. You have used " + numTries + " tries. Please try again.")
    /*If the first condition is not met, the function will then evaluate this one next. If the player's guess is higher (closer to A) than the target, this alert will be triggered. */
    } else if (guess > target) {
        alert("Not quite! Your color is alphabetically higher (closer to A) than mine. You have used " + numTries + " tries. Try again!")
    /*If neither above conditions are met, the function will then evaluate this one. If the player's guess is lower (closer to Z) than the target, this alert will be triggered. */
    } else if (guess < target) {
        alert("Not quite! Your color is alphabetically lower (closer to Z) than mine. You have used " + numTries + " tries. Try again!")
    /*This final condition should only occur if a guess matches the target. If so, the value held in "result" will change to Boolean true, and the function will exit the block. Only then will code after these conditionals be run. */
    } else {
        result = true;
    }
    /*The value held in "result" is returned, and can be used outside this function block. */
    return result;

}